(include "./lang.egg")
;;; Types for Lakeroad expressions.
(datatype Type
  ;;; Bitvector type.
  (Bitvector i64)
  ;;; Module type: when `apply`ed, gives back the indicated type. This could be
  ;;; a lot more rigorous. Currently will not allow for checking correct input
  ;;; types.
  (ModuleType Type))

;;; Indicates that a Lakeroad expression has a given type.
(relation HasType (Expr Type))

;;; Indicates that all input and output bitwidths must match for this type of 
;;; op.
(relation AllBitwidthsMatch (Op))
(AllBitwidthsMatch (And))
(AllBitwidthsMatch (Or))
(AllBitwidthsMatch (Xor))
(AllBitwidthsMatch (Shr))
; Have to write this one as a rule, unfortunately.
(ruleset core)
(rule ((Reg n)) ((AllBitwidthsMatch (Reg n))) :ruleset core)

;;; Indicates that, for the op, the input bitwidths must match, and the output
;;; bitwidth is the indicated constant.
(relation InputBitwidthsMatchOutputBitwidthConst (Op i64))
(InputBitwidthsMatchOutputBitwidthConst (Eq) 1)

;;; Bitwise: Indicates that an op `(op a b ...)` can be written 
;;; `(concat (op a[0] b[0] ...) (op a[1] b[1] ...) ...)`.
(relation Bitwise (Op))
(Bitwise (And))
(Bitwise (Or))
(Bitwise (Xor))


;;; Typing judgements.
(ruleset typing)
(rule
  ((Wire name bw))
  ((HasType (Wire name bw) (Bitvector bw)))
  :ruleset typing)
(rule
  ((Var name bw))
  ((HasType (Var name bw) (Bitvector bw)))
  :ruleset typing)
(rule
  ((Op0 (BV val bw)))
  ((HasType (Op0 (BV val bw)) (Bitvector bw)))
  :ruleset typing)
(rule
  ((Op1 op i0)
   (HasType i0 (Bitvector bw))
   (AllBitwidthsMatch op))
  ((HasType (Op1 op i0) (Bitvector bw)))
  :ruleset typing)
(rule
  ((Op2 op i0 i1)
   (HasType i0 (Bitvector bw))
   (HasType i1 (Bitvector bw))
   (AllBitwidthsMatch op))
  ((HasType (Op2 op i0 i1) (Bitvector bw)))
  :ruleset typing)
(rule
  ((Op3 op i0 i1 i2)
   (HasType i0 (Bitvector bw))
   (HasType i1 (Bitvector bw))
   (HasType i2 (Bitvector bw))
   (AllBitwidthsMatch op))
  ((HasType (Op3 op i0 i1 i2) (Bitvector bw)))
  :ruleset typing)
(rule
  ((Op1 op i0)
   (HasType i0 (Bitvector bw))
   (InputBitwidthsMatchOutputBitwidthConst op out-bw))
  ((HasType (Op1 op i0) (Bitvector out-bw)))
  :ruleset typing)
(rule
  ((Op2 op i0 i1)
   (HasType i0 (Bitvector bw))
   (HasType i1 (Bitvector bw))
   (InputBitwidthsMatchOutputBitwidthConst op out-bw))
  ((HasType (Op2 op i0 i1) (Bitvector out-bw)))
  :ruleset typing)
(rule
  ((Op3 op i0 i1 i2)
   (HasType i0 (Bitvector bw))
   (HasType i1 (Bitvector bw))
   (HasType i2 (Bitvector bw))
   (InputBitwidthsMatchOutputBitwidthConst op out-bw))
  ((HasType (Op3 op i0 i1 i2) (Bitvector out-bw)))
  :ruleset typing)
(rule
  ((Op3 (Mux) sel-expr a-expr b-expr)
   (HasType sel-expr (Bitvector 1))
   (HasType a-expr (Bitvector bw))
   (HasType b-expr (Bitvector bw)))
  ((HasType (Op3 (Mux) sel-expr a-expr b-expr) (Bitvector bw)))
  :ruleset typing)
(rule
  ((Op2 (Concat) a-expr b-expr)
   (HasType a-expr (Bitvector m))
   (HasType b-expr (Bitvector n)))
  ((HasType (Op2 (Concat) a-expr b-expr) (Bitvector (+ m n))))
  :ruleset typing)
(rule
  ((Op1 (Extract high low) expr)
   (HasType expr (Bitvector n))
   (>= 0 low)
   (< high n))
  ((HasType (Op1 (Extract high low) expr) (Bitvector (+ 1 (- high low)))))
  :ruleset typing)
(rule
  ((Op1 (ZeroExtend bitwidth) expr))
  ((HasType (Op1 (ZeroExtend bitwidth) expr) (Bitvector bitwidth)))
  :ruleset typing)
(rule
  ((Op1 (Reg init) expr)
   (HasType expr (Bitvector n)))
  ((HasType (Op1 (Reg init) expr) (Bitvector n)))
  :ruleset typing)


