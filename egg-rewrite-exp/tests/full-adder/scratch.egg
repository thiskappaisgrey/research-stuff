;; (function ripple-carry (String) Expr :cost 100000)
;; (ruleset rewrites)

;
;; (rule ((= (Op2 (And) a b) carry) ; o_carry
;;        (= (Op2 (Xor) a b) sum)) ; o_sum
;;       (
;;        ; when it finds this in the egraph, I can just do whatver
;;        ; here, I just add them to a function but maybe in the Rust code I can splice the definition out..?

;;        ; union half-adder with concat XOR + AND
;;        ; add another union - union the AND with extract from concat
;;        ; union 
;;        ;; (union (half-adds name) (Sketch2 (HalfAdd) a b))

;;        ;; TODO instead of unioning - I think it's better for the half_add to be bound to concat
;;        (let half_add (Module "HalfAdd" (Concat a b)))
;;        ;; (union half_add  carry)
;;        ;; (union half_add  sum)
;;        (union carry (Extract 1 0 half_add))
;;        (union sum (Extract 2 1 half_add))
       
;;        ;; what happens when I delete here?
;;        ;; TODO - the concat doesn't contain what the wires going in are..?
;;        ;; so when I delete, the inputs are not connected properly
;;        ;; I don't have to delete, but the delete models the extraction
;;        (delete (Op2 (And) a b))
;;        (delete (Op2 (Xor) a b))
       
;;        )
;;       :ruleset myrewrites)
