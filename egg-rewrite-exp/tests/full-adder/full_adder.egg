(include "egglog_src/lakeroad_rewrites.egg")

;; (function ripple-carry (String) Expr :cost 100000)
(ruleset rewrites)

 (rule
(
(= (Op2 (And) i_sum i_carry) o_sum)
(= (Op2 (Xor) i_sum i_carry) o_carry)
)
((let halfadd (Module "HalfAdd" (Concat i_sum i_carry )))
(union o_sum (Extract 1 0 halfadd))
(union o_carry (Extract 2 1 halfadd))
) :ruleset rewrites)
;; (rule ((= (Op2 (And) a b) carry) ; o_carry
;;        (= (Op2 (Xor) a b) sum)) ; o_sum
;;       (
;;        ; when it finds this in the egraph, I can just do whatver
;;        ; here, I just add them to a function but maybe in the Rust code I can splice the definition out..?

;;        ; union half-adder with concat XOR + AND
;;        ; add another union - union the AND with extract from concat
;;        ; union 
;;        ;; (union (half-adds name) (Sketch2 (HalfAdd) a b))

;;        ;; TODO instead of unioning - I think it's better for the half_add to be bound to concat
;;        (let half_add (Module "HalfAdd" (Concat a b)))
;;        ;; (union half_add  carry)
;;        ;; (union half_add  sum)
;;        (union carry (Extract 1 0 half_add))
;;        (union sum (Extract 2 1 half_add))
       
;;        ;; what happens when I delete here?
;;        ;; TODO - the concat doesn't contain what the wires going in are..?
;;        ;; so when I delete, the inputs are not connected properly
;;        ;; I don't have to delete, but the delete models the extraction
;;        (delete (Op2 (And) a b))
;;        (delete (Op2 (Xor) a b))
       
;;        )
;;       :ruleset myrewrites)
      
; wire declarations
; $flatten\half_adder1.$and$half_adder.v:17$3_Y
(let v0 (Wire "v0" 1))
; $flatten\half_adder1.$xor$half_adder.v:16$2_Y
(let v1 (Wire "v1" 1))
; $flatten\half_adder2.$and$half_adder.v:17$3_Y
(let v2 (Wire "v2" 1))
; $flatten\half_adder2.$xor$half_adder.v:16$2_Y
(let v3 (Wire "v3" 1))
; $or$full_adder.v:34$1_Y
(let v4 (Wire "v4" 1))
; i_bit1
(let v5 (Wire "v5" 1))
; i_bit2
(let v6 (Wire "v6" 1))
; i_cin
(let v7 (Wire "v7" 1))

; cells
(union v0 (Op2 (And) v5 v6))
(union v1 (Op2 (Xor) v5 v6))
(union v2 (Op2 (And) v7 v1))
(union v3 (Op2 (Xor) v7 v1))
(union v4 (Op2 (Or) v0 v2))

; inputs
(let i_bit1 (Var "i_bit1" 1))
(union v5 i_bit1)
(let i_bit2 (Var "i_bit2" 1))
(union v6 i_bit2)
(let i_cin (Var "i_cin" 1))
(union v7 i_cin)

; outputs
(let o_carry v4)
(let o_sum v3)
;; (run-schedule
;;  (repeat 100
;;          (saturate typing)))
; delete wire expressions
(delete (Wire "v0" 1))
(delete (Wire "v1" 1))
(delete (Wire "v2" 1))
(delete (Wire "v3" 1))
(delete (Wire "v4" 1))
(delete (Wire "v5" 1))
(delete (Wire "v6" 1))
(delete (Wire "v7" 1))

(run-schedule
 (repeat 100
         (saturate rewrites)
         ))
(delete (Xor))
(delete (And))
;; TODO how would I detect the full/half adder though..?
;; You can't because of the tensor (wires run in parallel)
;; (query-extract (HasType o_sum (Bitvector 1)))
